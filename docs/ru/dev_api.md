# Queen API для разработчика

Данная статья описывает интерфейс взаимодействия с системой QUEEN.

## Подключение к Queen Room

Подключение к системе _Queen Room_ осуществляется через обычный TCP-сокет, т.е. _Queen Room_ открывает слушающий сокет (по умолчанию на _0.0.0.0:4444_) и ожидает соединения абонентов.
Адрес _0.0.0.0:4444_ может быть изменен в свойствах проекта (project -> server).
Подключиться к Queen Room возможно при помощи обычного терминала, например, [PuTTY](https://www.putty.org) с параметрами сокета "Raw".
В общем случае к _Queen Room_ можно подключиться при помощи любой программы, используя командный интерфейс управления с открытым форматом: на входе - строковая команда, а на выходе - XML-документ.  

!> Для корректной работы терминала _PuTTY_ желательно выставить галочку "Implicit CR in every LF" в настройках "Terminal".

Общий формат команд на псевдокоде выглядит так: `getsmth` or `setsmth`. На любые команд сервер отвечает следующим образом:  

```xml
<response type='getsmth' id='id' status='ok/error' time='HH:MM:SS.MS'>TEXT</response>
```

- **type** - повторяет запрос;
- **id** - идентификатор запроса;
- **status** - статус запроса, при успешном запрос равен `ok`, а в случае ошибки - `error`;
- **time** - если сценарий запущен, то это время сценария в формате HH:MM:SS.MS (часы, минуты, секунды и десятая часть секунды), если сценарий не запущен или запрос не подразумевает время в ответе, то либо не указывается, либо `-`.
- **TEXT** - содержит либо строку ошибки, если `status='error'`, либо результат самого ответа, если `status='ok'`.  

Идентификатор задается в самом начале запроса в квадратных скобках. Например, если задается команда `[2467]getstates` (получить текущие состояния электроники), то в ответ на такую команду _Queen Room_ выставит атрибут `id='2467'`.
Если в команде отсутствует идентификатор запроса, например, просто `getstates`, то _Queen Room_ выставит `id='undefined'`.  

## Получение статических состояний (STATIC)

Здесь будут перечислены команды, которые получают данные от _Queen Room_, не осуществляя никаких управляющих воздействий.
Данные команды будут далее называться **STATIC** и должны вызываться единожды при установлении связи с _Queen Room_, так как возвращают один и тот же результат.

### Получение файловой структуры 

Формат: `getfs [filter]`

Примеры команд:

| Пример                         | Описание                     |
|--------------------------------|------------------------------|
| **getfs** \*.\*                | получить всё файловое дерево |
| **getfs** \*.mp3,\*.wav,\*.ogg | получить все звуковые файлы  |
| **getfs** \*.mef               | получить все макроэффекты    |

В ответ на эту команду _Queen Room_ вышлет дерево файлов и каталогов относительно расположения _Queen Room_ и глубже в формате XML.
Пример ответа:  

```xml
<response type='getfs' status='ok'>  
  <folder name='.'>  
    <folder name='macroeffects'>  
      <file name='lose.mef'/>  
      <file name='tune.mef'/>  
      <file name='win.mef'/>  
    </folder>  
    <folder name='media'>  
      <folder name='img'>  
      </folder>  
      <folder name='snd'>  
        <file name='sound check.mp3'/>  
      </folder>  
    </folder>  
    <folder name='scenarios'>  
      <file name='scenario.xml'/>  
    </folder>  
    <file name='room.xml'/>  
    <file name='queen_room'/>  
  </folder>  
</response>  
```

Всё файловое дерево представлено в виде структуры папок (тег `<folder>`) и файлов (тег `<file>`). Вложенность тегов `<folder>` определяет иерархию папок.

### Получение файла описания комнаты room.xml

Формат: `getroom`

Примеры команд:

| Пример      | Описание               |
|-------------|------------------------|
| **getroom** | получить файл room.xml |


В ответ на эту команду _Queen Room_ вышлет _room.xml_ в формате XML, вложив _room.xml_ в тег `<response>`:

```xml
<response type='getroom' status='ok'>
    <...room.xml...>
</response>
```

### Получение дерева скриптов

Формат: `getscripts`

Примеры команд:

| Пример         | Описание                 |
|----------------|--------------------------|
| **getscripts** | получить дерево скриптов |

В ответ на эту команду _Queen Room_ вышлет дерево скриптов в формате XML:

```xml
<response type='getscripts' status='ok'>  
  <macro name='m1.mef'></macro>
  <macro name='m2.mef'></macro>
  <macro name='m3.mef'></macro>
  <macro name='m4.mef'></macro>
  <macro name='m5.mef'></macro>
  <...other_macros...>
  <scenario name='scenario_1.xml' begin='stage_1'>
    <stage name='global'></stage>
    <stage name='stage_1' next='stage_2'></stage>
    <stage name='stage_2' next='stage_3'></stage>
    <...other_stages...>
    <stage name='stage_N' next=''></stage>
  </scenario>
  <...other_scenarios...>
</response>

```

Сначала идет перечисление всех макроэффектов для данного проекта (тег `<macro>`). Каждый макроэффект содержит атрибут `name` - имя макроэффекта (имя файла без расширения).
Далее перечисляются все сценарии в тегах `<scenario>`. Каждый сценарий содержит атрибут `name` - имя сценария (имя файла сценария без расширения) и название начальной стадии (атрибут `begin`).
В рамках сценария перечислены все стадии в тегах `<stage>`, каждая из которых имеет имя (атрибут `name`) и указатель на следующую стадию (атрибут `next`).
Каждая стадия, включая и глобальную, содержат перечисление контекстных подсказок в тегах `<clue>`, а атрибут `macro` ссылается на соответствующий макроэффект.
Поскольку подсказка - это макроэффект, то технически подсказкой может быть что угодно: от мигания лампочкой и проигрывания звука, до сложных эффектов с выдачей текстовых подсказок на _Queen TV_.

## Получение динамических состояний (DYNAMIC)

Здесь будут перечислены команды, которые получают данные от _Queen Room_, не осуществляя никаких управляющих воздействий.
Данные команды будут далее называться **DYNAMIC** и должны вызываться периодически после установления связи с _Queen Room_ с целью получения текущих состояний различных объектов.

### Получение отклика программы (ping)

Формат: `ping`

Примеры команд:  

| Пример   | Описание        |
|----------|-----------------|
| **ping** | получить отклик |

В ответ на эту команду _Queen Room_ вышлет следующий XML:  

```xml
<response type='ping' status='ok'></response>  
```

Эта команда нужна просто для проверки связи с _Queen Room_.

### Получение состояния объектов комнаты

Формат: `get [type.object.attribute]`

Примеры команд:

| Пример                        | Описание                                                                                 |
|-------------------------------|------------------------------------------------------------------------------------------|
| **get** din.startbutton.state | получить состояние дискретного входа для кнопки "startbutton"                            |
| **get** out.cachelock.state   | получить состояние дискретного выхода (реле) электромагнитного замка тайника "cachelock" |
| **get** ain.photosensor.state | получить состояние аналогового входа датчика "photosensor"                               |
| **get** pwm.led.state         | получить состояние яркости (ШИМ-сигнала) светильника "led"                               |
| **get** pwm.led.strobo        | получить состояние флага стробоскопа (ШИМ-сигнала) светильника "led"                     |
| **get** uni.rfid1.state       | получить состояние uni-объекта бесконтактного датчика "rfid1"                            |
| **get** var.somevar.state     | получить состояние переменной "somevar"                                                  |

В ответ на эту команду _Queen Room_ вышлет состояния объекта комнаты в формате XML, примеры:  

```xml
<response type='get din.startbutton.state' status='ok'>on</response>  

<response type='get out.cachelock.state' status='ok'>off</response>

<response type='get ain.photosensor.state' status='ok'>980</response>

<response type='get pwm.led.state' status='ok'>255</response>  

<response type='get pwm.led.strobo' status='ok'>high</response>  

<response type='get uni.rfid1.state' status='ok'>236728347</response> 
```

Если команда некорректна, то будет выслано сообщение об ошибке.

### Получение состояния всех объектов комнаты  

Формат: `getstates`

Примеры команд:  

| Пример            | Описание                                 |
|-------------------|------------------------------------------|
| **getstates**     | получить состояния всех объектов комнаты |

В ответ на эту команду _Queen Room_ вышлет состояния всех объектов комнаты в формате XML:  

```xml
<response type='getstates' status='ok'>
  <item type='pwm' obj='pwm1' attr='state' value='128'/>
  <item type='out' obj='out1' attr='state' value='on'/>
  <...>
</response>
```

### Получение состояние текущего режима и стадии

Формат: `getmode`

Примеры команд:  

| Пример      | Описание                                    |
|-------------|---------------------------------------------|
| **getmode** | получить состояние текущего режима и стадии |

В ответ на эту команду _Queen Room_ вышлет состояние текущего режима и стадии в формате XML, примеры:  

```xml
<response type='getmode' status='ok'>idle</response>

<response type='getmode' status='ok'>tune</response>

<response type='getmode' status='ok'>ready</response>

<response type='getmode' status='ok'>win</response>

<response type='getmode' status='ok'>lose</response>

<response type='getmode' status='ok'>godmode:stage</response>

<response type='getmode' status='ok'>playing:stage</response>

<response type='getmode' status='ok'>paused:stage</response>
```

Выше перечислены режимы:
- **idle** - простой (квест в ручном режиме, сценарий выключен);
- **tune** - перезарядка;
- **ready** - готовность сценария;
- **win** - квест окончен в состоянии победы;
- **lose** - квест окончен в состоянии поражения.

Далее приведены три режима, которые описывают игровые режимы через разделитель ":" с указанием текущей стадии сценария, где
- **godmode** - режим бога (время не идет, но все работает);
- **playing** - обычный режим проигрывания сценария с обратным таймером;
- **paused** - режим паузы игры, где все как бы "замирает";
- **stage** - наименование текущей стадии.

## Команды управления (CONTROL)

Здесь будут перечислены команды, которые управляют состояниями _Queen Room_. Данные команды будут далее называться **CONTROL**.  

### Установка значения переменных и объектов электроники

Формат: `set [type.object.attribute] [value]`
Примеры команд:

| Пример                                | Описание                                                                                   |
|---------------------------------------|--------------------------------------------------------------------------------------------|
| **set** din.startbutton.state **on**  | установить состояние дискретного входа для кнопки "startbutton"                            |
| **set** out.cachelock.state **off**   | установить состояние дискретного выхода (реле) электромагнитного замка тайника "cachelock" |
| **set** ain.photosensor.state **980** | установить состояние аналогового входа датчика "photosensor"                               |
| **set** pwm.led.state **255**         | установить состояние яркости (ШИМ-сигнала) светильника "led"                               |
| **set** pwm.led.strobo **1**          | установить состояние флага стробоскопа (ШИМ-сигнала) светильника "led"                     |
| **set** uni.rfid1.state **236728347** | установить состояние uni-объекта бесконтактного датчика "rfid1"                            |
| **set** var.somevar.state **16500**   | установить состояние переменной "somevar"                                                  |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом`status='ok'` или `status='error'`.

### Управление сценарием и переходами

Формат: `setmode [name]`

Примеры команд:

| Пример              | Описание                   |
|---------------------|----------------------------|
| **setmode** idle    | сбросить сценарий          |
| **setmode** tune    | перейти в режим наладки    |
| **setmode** ready   | перейти в режим готовности |
| **setmode** playing | начать сценарий            |
| **setmode** paused  | остановить сценарий        |
| **setmode** godmode | перейти в режим бога       |
| **setmode** win     | принудительная победа      |
| **setmode** lose    | принудительное поражение   |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.  

### Пропуск текущей стадии

Формат: `skipstage`

Примеры команд:  

| Пример        | Описание               |
|---------------|------------------------|
| **skipstage** | пропуск текущей стадии |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.

### Проигрывание макроэффектов

Формат: `play [macroeffect.mef]`

Примеры команд:  

| Пример                    | Описание                                 |
|---------------------------|------------------------------------------|
| **play** sarcofagopen.mef | проиграть макроэффект "sarcofagopen.mef" |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.

### Установка текущего языка

Формат: `setlanguage [name]`

Примеры команд:  

| Пример              | Описание                   |
|---------------------|----------------------------|
| **setlanguage** rus | установить русский язык    |
| **setlanguage** eng | установить английский язык |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.

### Установка текущего сценария

Формат: `setscenario [name]`

Примеры команд:  

| Пример                    | Описание                           |
|---------------------------|------------------------------------|
| **setscenario** christmas | установить рождественский сценарий |
| **setscenario** children  | установить детский сценарий        |
| **setscenario** scary     | установить страшный сценарий       |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.

### Установка имени абонента

Формат: `setname name`

Примеры команд:  

| Пример              | Описание               |
|---------------------|------------------------|
| **setname** backend | установить имя backend |
| **setname** putty   | установить имя putty   |

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.

### Отправка сообщения абонентам 

Формат: `send abonent 'text'`

Примеры команд:  

| Пример                                  | Описание                                                       |
|-----------------------------------------|----------------------------------------------------------------|
| **send** all 'hello everyone'           | отправить "hello everyone" всем абонентам                      |
| **send** subscribed 'hello subscribers' | отправить "hello subscribers" всем подписавшимся абонентам     |
| **send** putty 'hello friend'           | отправить абоненту по имени "putty" приветствие "hello friend" |

!> Текст 'text' может содержать пробелы, поэтому его необходимо заключить в одинарные кавычки.
Внутри текста использование одинарных кавычек недопсутимо.

В ответ на эту команду _Queen Room_ вышлет обычный результат команды в формате XML с атрибутом `status='ok'` или `status='error'`.
А целевому абоненту(ам) будет передано сообщение в следующем формате:  

```xml
<response type='event:send' status='ok' time='HH:MM:SS.MS'>text</response>
```

## Получение динамических состояний в событийном режиме (EVENTS)

Некоторые состояния целесообразно получать по изменениям, а не постоянно опрашивая сервер. Для этого нужно подписаться на рассылку событий.

Формат: `subscribe`

Примеры команд:

| Пример         | Описание                     |
|----------------|------------------------------|
| **subscribe**  | подписаться на поток событий |

В ответ на эту команду _Queen Room_ вышлет результат команды в формате XML:  

```xml
<response type='subscribe' status='ok'></response>  
```

Также есть команада, которая позволяет отписаться от потока событий.

Формат: `unsubscribe`  

| Пример          | Описание                     |
|-----------------|------------------------------|
| **unsubscribe** | отписаться от потока событий |  

В ответ на эту команду _Queen Room_ вышлет результат команды в формате XML:  

```xml
<response type='unsubscribe' status='ok'></response>  
```

Сами события будут передаваться уже асинхронно для клиента также в XML формате:

```xml
<response type='type' status='ok' time='HH:MM:SS.MS'>text</response>  
```

Если квест запущен, то время указывает время квеста в формате HH:MM:SS.MS; если нет, то `time='-'`.
Сразу за ответом на `subscribe` пересылаются начальные состояния по очевидным причинам, а только потом следуют изменения в контексте подписки.

Возможные варианты событий описаны ниже.

### Изменение режима игры (mode)

Возможные варианты:

```xml
<response type='event:mode' status='ok' time='HH:MM:SS.MS'>idle</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>tune</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>ready</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>win</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>lose</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>godmode</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>playing</response>

<response type='event:mode' status='ok' time='HH:MM:SS.MS'>paused</response>
```

### Изменение стадии сценария (stage)

Возможные варианты:

```xml
<response type='event:stage' status='ok' time='HH:MM:SS.MS'>oldstage:newstage:reason</response>  
```

Через разделитель ":" в теле сообщения передаётся следующие значения:
- **oldstage** - имя старой стадии; 
- **newstage** - имя новой стадии;
- **reason** - причина перехода: 
  - **skip** - пропуск шага;
  - **resolved** - естественное решение загадки.

!> При инициализации, когда клиент подключается к _Queen Room_, вместо формата `oldstage:newstage:reason` передается просто `newstage`.

### Изменение сценария (scenario)

Возможные варианты:

```xml
<response type='event:scenario' status='ok' time='HH:MM:SS.MS'>scenario_name</response>  
```

Где `scenario_name` - это имя сценария из запроса `getscripts`.



### Изменение языка (language)

Возможные варианты:

```xml
<response type='event:language' status='ok' time='HH:MM:SS.MS'>rus</response>  

<response type='event:language' status='ok' time='HH:MM:SS.MS'>eng</response> 

<response type='event:language' status='ok' time='HH:MM:SS.MS'>esp</response>

<response type='event:language' status='ok' time='HH:MM:SS.MS'>ita</response>  
```

Наименование языка передается внутри тега.

### Уведомления (notifications)

Возможные варианты:

```xml
<response type='event:reminder' status='ok' time='HH:MM:SS.MS'>text</response>  

<response type='event:json' status='ok' time='HH:MM:SS.MS'>text in json format</response>  
```

Уведомления генерируются, когда в компоненте типа logger текст сообщения начинается с ключевого слова `:reminder:` или `:json:`.
А в поле `text` XML-сообщения вставляется строка, которая следует за любым из вышеуказанных ключевых слов.
Тип `:reminder:` используется для отправки уведомления с обычной строкой, а для отправки JSON используется ключевое слово `:json:`.

Для уведомлений с типом `type='event:json'` нужно указать JSON объект в качестве тела сообщения.
То есть если в logger строка имеет вид `:json:{"type":"http", "method":"post", "url":"targetUrl", "payload":"targetJSON"}`,
то в поле `text` XML-сообщения будет вставлен JSON:  

```json
{"type":"http", "method":"post", "url":"targetUrl", "payload":"targetJSON"}  
```

Этот функционал следует использовать для эффективной увязки Queen Room с web-приложениями, в частности с компонентом Queen Bridge, входящим в состав инфраструктуры Queen Web.
